### 4.1.2 실무적인 SQL 튜닝 절차 이해하기

1. SQL 문 실행결과 & 현황 파악
   * 결과 및 소요시간 확인
   * 조인/서브쿼리 구조
   * 동등/범위 조건
2. 가시적, 비가시적
   1. 가시적
      * 테이블의 데이터 건수
      * SELECT 절 컬럼 분석
      * 조건절 컬럼 분석
      * 그루핑/정렬 컬럼
   2. 비가시적
      * 실행계획
      * 인덱스 현황
      * 데이터 변경 추이
      * 업무적 특징
3. 튜닝 방향 판단 & 개선/적용

## 4.2 SQL 문 단순 수정으로 착한 쿼리 만들기

### 4.2.1 기본 키를 변형하는

* 튜닝 전 실행 계획
  * type 항목이 all 테이블 풀 스캔, 인덱스 없이 접근
* 튜닝 수행
  * 사원번호 열을 조건문으로 작성했으므로 기본 키로 빠르게 접근 가능
  * 가공하여 작성했어서 기본 키를 사용하지 않고 풀스캔 수행
  * 따라서 가공된 사원번호 열을 변경하여 기본 키를 사용할 수 있게 조정

### 4.2.2 사용하지 않는 함수를 포함하는

* 튜닝 수행
  * 성별 열에는 Null 값이 존재하지 않는다
  * ifnull() 함수를 처리하려고 db 내부적으로 별도 임시 테이블 만들어서 검사할 필요가 없다

### 4.2.3 형변환으로 인덱스를 활용하지 못하는

* 튜닝 수행
  * 사용여부 열은 문자열 char(1) 유형인데 where 절에서 숫자 유형으로 접근시 묵시적 형변환 발생
  * 인덱스 풀스캔이된 이유

### 4.2.4 열을 결합하여 사용하는

* 튜닝 전
  * 조건절로 데이터 접근하지만 테이블 풀 스캔사용
  * where 절의 concat 함수는 스토리지에서 가져온 후 mysql 이 실행 따라서 30만건 filtered 100
* 튜닝 후 실행 계획
  * 튜닝 전에는 30만 건 데이터에 접근했다면 후에는 102 건의 데이터에만 접근
  * where 절의 = 비교연산자로 스토리지 엔진에서 102 건 filtered 100

### 4.2.5 습관적으로 중복을 제거하는

* 튜닝 전 실행 계획
  * distinct 수행하고자 using temporary 만듬
* 튜닝 수행
  * 사원 테이블 기본키는 사원 번호. distinct 키워드로 정렬, 중복 제거 작업이 필요없다.

### 4.2.6 다수의 쿼리를 union 연산자로만 합치는

* 튜닝 수행
  * union 연산자로 통합되는 과정에서 각 select 문의 결과를 합친 뒤 중복 제거하고 출력
  * 사원번호라는 기본 키가 출력되는데 중복 제거하는 과정이 필요할지 고민
* 튜닝 후
  * 실행계획 세번째 행이 없어짐. union all 은 정렬, 중복 제거하는 작업이 없어 리소스 낭비 방지

### 4.2.7 인덱스 고려 없이 열을 사용하는

* 튜닝 수행
  * 성별, 성 인덱스를 활용하는데도 임시 테이블을 생성할지 고민. 인덱스 만으로 카운트 연산 수행할 수 있을지
* 튜닝 결과
  * 존재하는 인덱스를 활용하기 위해선 인덱스 순서대로 그룹

### 4.2.8 엉뚱한 인덱스를 사용하는

* 튜닝 전
  * 기본 키로 범위 스캔(range)을 한다
  * 스토리지 엔진으로 부터 기본 키 구성 사원번호 조건으로 데이터 가져온 뒤
  * mysql 엔진에서 남은 필터 조건(like)으로 추출하여 filtered 11.11 출력됨
  * 사원번호 데이터는 전체 70퍼, 입사일자 데이터는 10퍼. 입사일자 열을 엑세스 조건으로 활용하는 것 검토
* 튜닝 후
  * 입사일자 인덱스를 활용해 범위 스캔 수행. 테이블에 접근하지 않고 인덱스만 사용하여 결과 출력
  * 이를 커버링 인덱스 스캔(using index)라고 한다.

### 4.2.9 동등 조건으로 인덱스를 사용하는

* 튜닝 수행
  * 출입문 인덱스로 인덱스 스캔 수행. 인덱스에 접근한 뒤 테이블에 랜덤 엑세스 방식

### 4.2.10 범위 조건으로 인덱스를 사용하는

* 튜닝 수행
  * 전체 데이터 17퍼에 해당하는 데이터를 가져온다면 인덱스 스캔으로 랜덤 엑세스 부하보다 풀 스캔 방식이 더 좋을 수도


## 4.3 테이블 조인 설정 변경으로 착한 쿼리 만들기

### 4.3.1 작은 테이블이 먼저 조인에 참여

* 튜닝 전
  * 드라이빙 테이블 부서 테이블, 드리븐 테이블 부서사원_매핑 테이블은 중첩 루프 조인을 수행
  * 부서사원_매핑 테이블은 인덱스 스캔 수행. rows 항목이 4만 이상. 대량의 데이터에 랜덤 엑세스하면 비효율적
* 튜닝 결과
  * 드라이빙 테이블에서 조인 비교 건수를 줄이도록 수행
  * straight_join 힌트 사용하여 from 절에 작성된 테이s블 순서대로 조인에 참여하게 고정(부서사원_매핑 테이블 먼저 접근, 부서 테이블 접근)
* 튜닝 후 실행 계획
  * 중첩 루프 조인으로 처리됨. 드라이빙 테이블은 부서사원_매핑 테이블. 랜덤 엑세스 없이 테이블 풀 스캔으로 한번에 다수의 페이지에 접근
  * 드라이빙 테이블에서 추출된 데이터 만큼 반복하여 접근하게 되는 드리븐 테이블은 부서 테이블

### 4.3.2 메인 테이블에 계속 의존하는

* 튜닝 수행
  * where 절의 서브쿼리에서 외부 테이블인 사원 테이블의 사원정보를 조건절로 받아야할지 고민

### 4.3.3 불필요한 조인을 수행하는

* 튜닝 수행
  * from 절의 인라인 뷰는 옵티마이저에 의해 조인 방식이 뷰 병합 최적화
* 튜닝 결과
  * 사원출입기록 테이블 데이터는 최종 결과에 사용되지 않고 존재 여부만 파악하면 되므로 exists 구문 변경